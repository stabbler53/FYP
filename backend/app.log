2023-12-27 12:07:28,272  * Debugger is active!
2023-12-27 12:07:28,277  * Debugger PIN: 994-283-381
2023-12-27 12:07:36,062 127.0.0.1 - - [27/Dec/2023 12:07:36] "GET / HTTP/1.1" 200 -
2023-12-27 12:07:36,255 127.0.0.1 - - [27/Dec/2023 12:07:36] "GET /static/main.js HTTP/1.1" 200 -
2023-12-27 12:10:11,733  * Detected change in 'd:\\FYPcode\\backend\\app.py', reloading
2023-12-27 12:10:12,364  * Debugger is active!
2023-12-27 12:10:12,368  * Debugger PIN: 994-283-381
2023-12-27 12:10:30,427  * Detected change in 'd:\\FYPcode\\backend\\temp_files\\temp_file.py', reloading
2023-12-27 12:10:31,045  * Debugger is active!
2023-12-27 12:10:31,049  * Debugger PIN: 994-283-381
2023-12-27 12:10:42,083  * Detected change in 'd:\\FYPcode\\backend\\temp_files\\temp_file.py', reloading
2023-12-27 12:10:42,693  * Debugger is active!
2023-12-27 12:10:42,697  * Debugger PIN: 994-283-381
2023-12-27 12:11:30,835  * Detected change in 'd:\\FYPcode\\backend\\temp_files\\temp_file.py', reloading
2023-12-27 12:11:31,356  * Debugger is active!
2023-12-27 12:11:31,361  * Debugger PIN: 994-283-381
2023-12-27 12:11:35,381  * Detected change in 'd:\\FYPcode\\backend\\app.py', reloading
2023-12-27 12:11:35,884  * Debugger is active!
2023-12-27 12:11:35,888  * Debugger PIN: 994-283-381
2023-12-27 12:11:38,906  * Detected change in 'd:\\FYPcode\\backend\\temp_files\\temp_file.py', reloading
2023-12-27 12:11:39,493  * Debugger is active!
2023-12-27 12:11:39,498  * Debugger PIN: 994-283-381
2023-12-27 12:12:17,627  * Detected change in 'd:\\FYPcode\\backend\\app.py', reloading
2023-12-27 12:12:18,098  * Debugger is active!
2023-12-27 12:12:18,101  * Debugger PIN: 994-283-381
2023-12-27 12:13:24,146 [31m[1mWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.[0m
 * Running on http://127.0.0.1:5000
2023-12-27 12:13:24,146 [33mPress CTRL+C to quit[0m
2023-12-27 12:13:24,148  * Restarting with stat
2023-12-27 12:13:24,601  * Debugger is active!
2023-12-27 12:13:24,607  * Debugger PIN: 994-283-381
2023-12-27 12:13:28,149 127.0.0.1 - - [27/Dec/2023 12:13:28] "GET / HTTP/1.1" 200 -
2023-12-27 12:13:28,457 127.0.0.1 - - [27/Dec/2023 12:13:28] "[36mGET /static/main.js HTTP/1.1[0m" 304 -
2023-12-27 12:13:33,645  * Detected change in 'd:\\FYPcode\\backend\\temp_files\\temp_file.py', reloading
2023-12-27 12:13:33,807  * Restarting with stat
2023-12-27 12:13:34,225  * Debugger is active!
2023-12-27 12:13:34,228  * Debugger PIN: 994-283-381
2023-12-27 12:13:49,279  * Detected change in 'd:\\FYPcode\\backend\\app.py', reloading
2023-12-27 12:13:49,327  * Restarting with stat
2023-12-27 12:13:49,766  * Debugger is active!
2023-12-27 12:13:49,770  * Debugger PIN: 994-283-381
2023-12-27 12:17:24,275  * Detected change in 'd:\\FYPcode\\backend\\app.py', reloading
2023-12-27 12:17:24,442  * Restarting with stat
2023-12-27 12:17:24,922  * Debugger is active!
2023-12-27 12:17:24,927  * Debugger PIN: 994-283-381
2023-12-27 12:17:30,198 File Content:
import random
import logging
import pandas as pd
import numpy as np
from sklearn.metrics import accuracy_score
from keras.models import Sequential
from keras.layers import Dense
from keras import optimizers

logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s %(message)s',
                    handlers=[logging.FileHandler("ann_test.log"),
                              logging.StreamHandler()])

class ANN(Sequential):
    def __init__(self, child_weights=None):
        super().__init__()

        if child_weights is None:
            layer1 = Dense(8, input_shape=(8,), activation='sigmoid')
            layer2 = Dense(1, activation='sigmoid')
            self.add(layer1)
            self.add(layer2)
        else:
            self.add(
                Dense(
                    8,
                    input_shape=(8,),
                    activation='sigmoid',
                    weights=[child_weights[0], np.ones(8)])
            )
            self.add(
                Dense(
                    1,
                    activation='sigmoid',
                    weights=[child_weights[1], np.zeros(1)])
            )

    def forward_propagation(self, train_feature, train_label):
        predict_label = self.predict(train_feature.values)
        self.fitness = accuracy_score(train_label, predict_label.round())

def crossover(nn1, nn2):
    nn1_weights = []
    nn2_weights = []
    child_weights = []

    for layer in nn1.layers:
        nn1_weights.append(layer.get_weights()[0])

    for layer in nn2.layers:
        nn2_weights.append(layer.get_weights()[0])

    for i in range(len(nn1_weights)):
        split = random.randint(0, np.shape(nn1_weights[i])[1]-1)
        for j in range(split, np.shape(nn1_weights[i])[1]-1):
            nn1_weights[i][:, j] = nn2_weights[i][:, j]

        child_weights.append(nn1_weights[i])

    mutation(child_weights)

    child = ANN(child_weights)
    return child

def mutation(child_weights):
    selection = random.randint(0, len(child_weights)-1)
    mut = random.uniform(0, 1)
    if mut <= .05:
        child_weights[selection] *= random.randint(2, 5)
    else:
        pass

# Preprocess Data
df = pd.read_table('./diabetes.txt', header=None, encoding='gb2312', sep='\t')
df.astype(float)
df.pop(10)
df.pop(0)
label = df.pop(9)
train_feature = df[:576]
train_label = label[:576]
test_feature = df[576:]
test_label = label[576:]

networks = []
pool = []
generation = 0
population = 10

for i in range(population):
    networks.append(ANN())

max_fitness = 0
optimal_weights = []

epochs = 10

for i in range(epochs):
    generation += 1
    logging.debug("Generation: " + str(generation) + "\r\n")

    for ann in networks:
        ann.forward_propagation(train_feature, train_label)
        pool.append(ann)

    networks.clear()
    pool = sorted(pool, key=lambda x: x.fitness)
    pool.reverse()

    for i in range(len(pool)):
        if pool[i].fitness > max_fitness:
            max_fitness = pool[i].fitness
            logging.debug("Max Fitness: " + str(max_fitness) + "\r\n")

            optimal_weights = []
            for layer in pool[i].layers:
                optimal_weights.append(layer.get_weights()[0])
            logging.debug('optimal_weights: ' + str(optimal_weights)+"\r\n")

    for i in range(5):
        for j in range(2):
            temp = crossover(pool[i], random.choice(pool))
            networks.append(temp)

ann = ANN(optimal_weights)
predict_label = ann.predict(test_feature.values)
print('Test Accuracy: %.2f' % accuracy_score(test_label, predict_label.round()))

2023-12-27 12:26:24,772 File Content:
#Rashad Mohamed 2020355
import numpy as np
import pandas as pd
from numpy.random import randn

mylist = np.array([10,20,30])

labels = ['a','b','c']

d = {'a':10,'b':20,'c':30}

pd.Series(data=mylist)

pd.Series(data=mylist,index=labels)

pd.Series(d)

pd.Series(data=labels)

pd.Series([sum,print,len])

ser1 = pd.Series([1,2,3,4],index = ['QW','AB','CD','EF'])

ser2 = pd.Series([1,2,5,4],index = ['AB','CD','IJ','KL'])

print (ser1)

print (ser2)

ser1 + ser2 
np.random.seed(100)

df = pd.DataFrame(randn(5,4),['Q','W','E','R','T'],['Z','X','C','V'])


print (df)

df = pd.DataFrame(randn(5,4),index = 'Q W E R T'. split(),columns = 'Z X C V'.split())

print (df)


df['Z']

df['NEW'] = df['Z'] + df['X'] 

print (df)

df.drop('NEW',axis=1)

print (df)

df.drop('NEW', axis=1, inplace=True)

print(df)

print(df.loc['Q'])

print(df.iloc[0])

print(df.loc['Q',['Z','X']])

print(df>0)

print(df[df['Z']>0])

print(df[(df['Z'] > 0) & (df['C'] > 0)])

print(df[(df['X'] > 0) | (df['C'] > 0)])
 
print(df.reset_index())

newwind = 'AB CD EF GH IJ' .split()

df['index'] = newwind

print (df.set_index('index'))

outside = ['G1','G1','G1','G2','G2','G2']

inside = [1,2,3,1,2,3]

hier_index   = list(zip(outside,inside))

hier_index = pd.MultiIndex.from_tuples(hier_index)

print(hier_index)

df=pd.DataFrame(np.random.randn(6,3),index = hier_index,columns = ['C','D','E'])

print (df)

df.loc['G1']

df.index.names = ['Group','Num']

print(df)

df1 = pd.DataFrame({'Q':['Q0','Q1','Q2','Q3'],
                    'W':['W0','W1','W2','W3'],
                    'E':['E0','E1','E2','E3']},
                    index = [0,1,2,3])

df2 = pd.DataFrame({'Q':['Q0','Q5','Q6','Q7'],
                    'W':['W4','W5','W6','W7'],
                    'E':['E4','E5','E6','E7']},
                    index = [4,5,6,7])

print (df1)

pd.concat([df1,df2])

merged = pd.merge(df1,df2,how='inner', on='Q')

print (merged)
